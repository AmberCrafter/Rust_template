{
    // Place your snippets for rust here. Each snippet is defined under a snippet name and has a prefix, body and 
    // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
    // same ids are connected.
    // Example:
    // "Print to console": {
    //  "prefix": "log",
    //  "body": [
    //      "console.log('$1');",
    //      "$2"
    //  ],
    //  "description": "Log output to console"
    // }
    "Generate a lib context": {
        "prefix": "lib",
        "body": [
            "pub fn $1() {",
            "    $2",
            "}",
            "",
            "#[cfg(test)]",
            "mod test {",
            "    use super::*;",
            "    #[test]",
            "    fn case1() {",
            "        assert_eq!(None, None);",
            "    }",
            "}",
        ],
        "description": "Generate a lib context with test pattern"
    },
    "Generate a lib context about leetcode problem": {
        "prefix": "leetcode",
        "body": [
            "pub struct Solution {}",
            "impl Solution {",
            "    pub fn $1() {",
            "        $2",
            "    }",
            "}",
            "",
            "#[cfg(test)]",
            "mod test {",
            "    use super::*;",
            "    #[test]",
            "    fn case1() {",
            "        let inputs = None;",
            "        let except = None;",
            "        let output = None;",
            "        assert_eq!(except, output);",
            "    }",
            "}",
        ],
        "description": "Generate a lib context about leetcode problem with test case pattern"
    },

    "Generate a lib context about google kickstart problem": {
        "prefix": "kickstart",
        "body": [
            "use std::io::{StdinLock, StdoutLock};",
            "",
            "type Console<'a> = IO<StdinLock<'a>, StdoutLock<'a>>;",
            "pub struct IO<R, W: std::io::Write>(R, std::io::BufWriter<W>);",
            "",
            "impl<R: std::io::Read, W: std::io::Write> IO<R, W> {",
            "   pub fn new(r: R, w: W) -> IO<R, W> {",
            "       IO(r, std::io::BufWriter::new(w))",
            "   }",
            "   pub fn write<S: ToString>(&mut self, s: S) {",
            "       use std::io::Write;",
            "       self.1.write_all(s.to_string().as_bytes()).unwrap();",
            "   }",
            "   pub fn read<T: std::str::FromStr>(&mut self) -> T {",
            "       use std::io::Read;",
            "       let buf = self",
            "           .0",
            "           .by_ref()",
            "           .bytes()",
            "           .map(|b| b.unwrap())",
            "           .skip_while(|&b| b == b' ' || b == b'\\n' || b == b'\\r' || b == b'\\t')",
            "           .take_while(|&b| b != b' ' && b != b'\\n' && b != b'\\r' && b != b'\\t')",
            "           .collect::<Vec<_>>();",
            "       unsafe { std::str::from_utf8_unchecked(&buf) }",
            "           .parse()",
            "           .ok()",
            "           .expect(\"Parse error.\")",
            "   }",
            "   pub fn usize0(&mut self) -> usize {",
            "       self.read::<usize>() - 1",
            "   }",
            "   pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {",
            "       (0..n).map(|_| self.read()).collect()",
            "   }",
            "   pub fn chars(&mut self) -> Vec<char> {",
            "       self.read::<String>().chars().collect()",
            "   }",
            "",
            "   pub fn binary_vec(&mut self) -> Vec<u8> {",
            "       self.read::<String>()",
            "           .bytes()",
            "           .map(|b| b - b'0')",
            "           .collect()",
            "   }",
            "}",
            "",
            "struct Solution {}",
            "",
            "impl Solution {",
            "   pub fn solve(console: &mut Console) -> $1{",
            "       $2",
            "   }",
            "}",
            "",
            "fn main() {",
            "   let (r, w) = (std::io::stdin(), std::io::stdout());",
            "   let mut console: Console = IO::new(r.lock(), w.lock());",
            "",
            "   let nums:usize = console.read();",
            "",
            "   for i in 0..nums  {",
            "       let result = Solution::solve(&mut console);",
            "       console.write(format!(",
            "           \"Case #{idx}: {value}\\n\",",
            "           idx=i+1,",
            "           value=result",
            "       ))",
            "   }",
            "}",
            "",
            "#[cfg(test)]",
            "mod tests {",
            "    use super::*;",
            "    #[test]",
            "    fn case1() {",
            "        main();",
            "    }",
            "}",
        ],
        "description": "Generate a lib context about google kickstart problem with test case pattern"
    },
    "Generate a IO structure to give some useful feature to stdin and stdout": {
        "prefix": "struct IO",
        "body": [
            "type Console<'a> = IO<StdinLock<'a>, StdoutLock<'a>>;",
            "pub struct IO<R, W: std::io::Write>(R, std::io::BufWriter<W>);",
            "",
            "impl<R: std::io::Read, W: std::io::Write> IO<R, W> {",
            "    pub fn new(r: R, w: W) -> IO<R, W> {",
            "        IO(r, std::io::BufWriter::new(w))",
            "    }",
            "    pub fn write<S: ToString>(&mut self, s: S) {",
            "        use std::io::Write;",
            "        self.1.write_all(s.to_string().as_bytes()).unwrap();",
            "    }",
            "    pub fn read<T: std::str::FromStr>(&mut self) -> T {",
            "        use std::io::Read;",
            "        let buf = self",
            "            .0",
            "            .by_ref()",
            "            .bytes()",
            "            .map(|b| b.unwrap())",
            "            .skip_while(|&b| b == b' ' || b == b'\\n' || b == b'\\r' || b == b'\\t')",
            "            .take_while(|&b| b != b' ' && b != b'\\n' && b != b'\\r' && b != b'\\t')",
            "            .collect::<Vec<_>>();",
            "        unsafe { std::str::from_utf8_unchecked(&buf) }",
            "            .parse()",
            "            .ok()",
            "            .expect(\"Parse error.\")",
            "    }",
            "    pub fn usize0(&mut self) -> usize {",
            "        self.read::<usize>() - 1",
            "    }",
            "    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {",
            "        (0..n).map(|_| self.read()).collect()",
            "    }",
            "    pub fn chars(&mut self) -> Vec<char> {",
            "        self.read::<String>().chars().collect()",
            "    }",
            "",
            "    pub fn binary_vec(&mut self) -> Vec<u8> {",
            "        self.read::<String>()",
            "            .bytes()",
            "            .map(|b| b - b'0')",
            "            .collect()",
            "    }",
            "}"
        ],
        "description": "ref: https://gist.github.com/robert-king/51b60cdc6ccd1a9b42ae02897dd7f190"
    },
    "Generate a IO pattern for stdin and stdout": {
        "prefix": "console",
        "body": [
            "let (r, w) = (std::io::stdin(), std::io::stdout());",
            "let mut console: Console = IO::new(r.lock(), w.lock());"
        ],
        "description": "ref: https://gist.github.com/robert-king/51b60cdc6ccd1a9b42ae02897dd7f190"
    },
    "Generate a lib context about leetcode TreeNode problem": {
        "prefix": "leetcode_TreeNode",
        "body": [
            "use std::cell::RefCell;",
            "use std::rc::Rc;",
            "pub struct Solution {}",
            "// Definition for a binary tree node.",
            "#[derive(Debug, PartialEq, Eq)]",
            "pub struct TreeNode {",
            "    pub val: i32,",
            "    pub left: Option<Rc<RefCell<TreeNode>>>,",
            "    pub right: Option<Rc<RefCell<TreeNode>>>,",
            "}",
            "",
            "impl TreeNode {",
            "    #[inline]",
            "    pub fn new(val: i32) -> Self {",
            "        TreeNode {",
            "            val,",
            "            left: None,",
            "            right: None,",
            "        }",
            "    }",
            "}",
            "impl Solution { ",
            "    pub fn $1() {",
            "        $2",
            "    }",
            "}",
            "",
            "#[cfg(test)]",
            "mod test {",
            "    use super::*;",
            "    #[test]",
            "    fn case1() {",
            "        let inputs = None;",
            "        let except = None;",
            "        let output = None;",
            "        assert_eq!(except, output);",
            "    }",
            "}",
            "",
            "use std::collections::VecDeque;",
            "impl TreeNode {",
            "    fn layer_gen(array: Vec<i32>, null_value: i32) -> Option<Rc<RefCell<TreeNode>>> {",
            "        // const NULL_VALUE: i32 = -99;",
            "    ",
            "        let mut root = None;",
            "        let mut idx = 0;",
            "        let mut parent_queue = VecDeque::new();",
            "        while idx<array.len() {",
            "            if root.is_none() {",
            "                root.replace(Rc::new(RefCell::new(TreeNode::new(array[idx]))));",
            "                parent_queue.push_back(",
            "                    root.clone()",
            "                );",
            "            } else {",
            "                let node = parent_queue.pop_front().expect(\"parent_queue is empty\");",
            "                let parent = Rc::clone(node.as_ref().unwrap());",
            "                // left leaf",
            "                if array[idx]!=null_value {",
            "                    parent.borrow_mut().left = Some(Rc::new(RefCell::new(TreeNode::new(array[idx]))));",
            "                    parent_queue.push_back(",
            "                        parent.borrow().left.clone()",
            "                    );",
            "                }",
            "                idx+=1;",
            "    ",
            "                if idx<array.len() {",
            "                    // right leaf",
            "                    if array[idx]!=null_value {",
            "                        parent.borrow_mut().right = Some(Rc::new(RefCell::new(TreeNode::new(array[idx]))));",
            "                        parent_queue.push_back(",
            "                            parent.borrow().right.clone()",
            "                        );",
            "                    }",
            "                }",
            "            }",
            "            idx+=1;",
            "        }",
            "        root ",
            "    }",
            "}",
        ],
        "description": "Generate a lib context about leetcode problem with test case pattern"
    },
    "Generate a lib context about leetcode ListNode problem": {
        "prefix": "leetcode_ListNode",
        "body": [
            "pub struct Solution {}",
            "// Definition for singly-linked list.",
            "#[derive(PartialEq, Eq, Clone, Debug)]",
            "pub struct ListNode {",
            "pub val: i32,",
            "pub next: Option<Box<ListNode>>",
            "}",
            "",
            "impl ListNode {",
            "    #[inline]",
            "    fn new(val: i32) -> Self {",
            "        ListNode {",
            "        next: None,",
            "        val",
            "        }",
            "    }",
            "}",
            "impl Solution {",
            "    pub fn $1 () {",
            "        $2",
            "    }",
            "}",
            "",
            "#[cfg(test)]",
            "mod test {",
            "    use super::*;",
            "    #[test]",
            "    fn case1() {",
            "        let inputs = None;",
            "        let except = None;",
            "        let output = None;",
            "        assert_eq!(except, output);",
            "    }",
            "}",
            "",
            "impl ListNode {",
            "    fn gen(arr: Vec<i32>) -> Option<Box<Self>> {",
            "        let mut root = Some(Box::new(ListNode::new(0)));",
            "        let mut cur = root.as_mut().unwrap();",
            "        for val in arr {",
            "            cur.next.replace(Box::new(ListNode::new(val)));",
            "            cur = cur.next.as_mut().unwrap();",
            "        }",
            "        root.unwrap().next",
            "    }",
            "}",
        ],
        "description": "Generate a lib context about leetcode problem with test case pattern"
    },
}


